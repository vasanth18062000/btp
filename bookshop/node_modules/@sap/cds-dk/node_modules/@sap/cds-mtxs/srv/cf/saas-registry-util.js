const https = require('https')
const { URL } = require('url')
const cds = require('@sap/cds/lib')
const LOG = cds.log('mtx'), DEBUG = cds.debug('mtx')
const axiosInstance = require('axios').create();
axiosInstance.interceptors.response.use(response => response, require('../../lib/pruneAxiosErrors'))

module.exports = new class SaasRegistryUtil {

    async sendResult(callbackUrl, tenant, payload, authHeader) {
        const { status, message, subscriptionUrl, saasCallbackUrl, saasRequestPayload } = payload
        const data = { subscriptionUrl, message, status }

        // call to custom application callback -> piggyback original SaaS registry payload
        if (saasCallbackUrl) {
            Object.assign(data, { tenant, saasCallbackUrl, saasRequestPayload })
        }

        const headers = {}
        headers.authorization = authHeader ?? `Bearer ${await _saasRegistryToken()}`

        LOG.info('sending result callback request to', callbackUrl)
        DEBUG?.('sending result with payload', data)

        // REVISIT: necessary?
        if (saasCallbackUrl) {
            Object.assign(headers, { status_callback: saasCallbackUrl })
        }

        try {
            return await axiosInstance(callbackUrl, { method: 'PUT', headers, data })
        } catch (error) {
            cds.error('Error sending result callback to saas-registry: ' + error.message)
        }
    }

    parseHeaders(headers) {
        const { prefer, status_callback, mtx_status_callback } = headers ?? {}
        const { multitenancy, 'cds.xt.SaasProvisioningService': sps } = cds.env.requires
        const { saas_registry_url } = multitenancy?.credentials ?? sps?.credentials ?? {}
        const callbackUrl = mtx_status_callback ?? (status_callback && saas_registry_url && new URL(status_callback, saas_registry_url).toString())
        return {
            callbackUrl,
            isCustomCallback: !!mtx_status_callback,
            saasCallbackUrlPath: status_callback,
            isSync: !(prefer?.includes('respond-async') || callbackUrl)
        }
    }
}

async function _saasRegistryToken() {
    const { multitenancy, 'cds.xt.SaasProvisioningService': sps } = cds.env.requires
    const { clientid, clientsecret, certurl, url, certificate, key } = multitenancy?.credentials ?? sps?.credentials ?? {}
    const auth = certificate ? { maxRedirects: 0, httpsAgent: new https.Agent({ cert: certificate, key }) }
                             : { auth: { username: clientid, password: clientsecret } }
    if (!clientid) {
        cds.error('No saas-registry credentials available from the application environment.', { status: 401 })
    }

    try {
        const authUrl = `${certurl ?? url}/oauth/token`
        LOG.info(`getting saas-registry auth token from ${authUrl}`)
        const { data: { access_token } } = await axiosInstance(authUrl, {
            method: 'POST',
            ...auth,
            params: {
                grant_type: 'client_credentials',
                response_type: 'token'
            }
        })
        if (!access_token) {
            cds.error('Could not get saas-registry token: token is empty', { status: 401 })
        }
        return access_token
    } catch (error) {
        cds.error('Could not get auth token for saas-registry: ' + error.message, { status: 401 })
    }
}
