
const KindToRequiresNameMap = {
    xsuaa: 'auth', // REVISIT: remove with ^8
    'xsuaa-auth': 'auth',
    'ias-auth': 'auth',
    'hana-cloud': 'db',
    hana: 'db',
    'hana-mt': 'db', // For compatibility only
    'sql-mt': 'db', // For compatibility only
    destinations: 'destinations',
    connectivity: 'connectivity',
    'audit-log': 'auditlog',
    'audit-log-to-restv2': 'auditlog',
    'enterprise-messaging': 'messaging',
    'enterprise-messaging-amqp': 'messaging',
    'enterprise-messaging-http': 'messaging',
    'enterprise-messaging-shared': 'messaging'
}

const PreferredKinds = [
    'hana-cloud',
    'xsuaa', // REVISIT: remove with ^8
    'xsuaa-auth'
];

const PLATFORM_TYPES = {
    'cf': 'Cloud Foundry',
    'k8s': 'Kubernetes'
}

class BindingUtil {
    static getRequiresNameFromKind(service, kind) {
        const requiresName = KindToRequiresNameMap[kind];
        if (!requiresName) throw new Error(`Unknown CDS service name for service "${service}". Please specify as argument for "cds bind".`)
        return requiresName;
    }

    /**
     * Determine kind value for services based on VCAP binding
     * information in the configuration.
     */
    static determineKinds(services) {
        const vcapServices = {}

        // Build VCAP_SERVICES
        for (const service of services) {
            service.kindCandidates = []

            const { vcap = {} } = service.binding || {};
            let { label, type } = vcap;
            type = type || label;
            if (!type) continue;

            if (!vcapServices[type]) vcapServices[type] = [];
            vcapServices[type].push({ credentials: { dummy: 'dummy' }, ...vcap, service });
        }

        // Auto configure services based on VCAP_SERVICES

        const cds = require('../cds');
        const env = cds.env.for('cds', process.cwd()); // REVISIT: This might load cds.env too early!

        if (!env._find_credentials_for_required_service) {
            throw new Error(`Please provide a service kind or update @sap/cds version to use the kind detection.`);
        }

        function findKindFor(kind, service) {
            const vcapService = env._find_credentials_for_required_service(kind, service, vcapServices);
            if (!vcapService) return;
            if (!Object.values(requires).find(require => require !== service && require.kind == kind))
                vcapService.service.kindCandidates.push(kind);
        }

        const requires = env.requires.kinds || {};
        for (const kind of Object.keys(requires)) {
            const requireService = requires[kind];
            findKindFor(kind, requireService);
            findKindFor(kind, { kind });
        }

        // Check if one "kind" per service was found
        for (const service of services) {
            const preferredKind = service.kindCandidates.find(kind => PreferredKinds.indexOf(kind) >= 0);
            if (preferredKind) {
                service.kind = preferredKind;
            } if (service.kindCandidates.length === 1) {
                service.kind = service.kindCandidates[0];
            }

            delete service.kindCandidates;
        }
    }

    static async checkIsJavaProject(projectPath) {
        const { constants, promises: fsp } = require('fs');
        const path = require('path');
        const pomXmlPath = path.join(projectPath, 'pom.xml');
        try {
            await fsp.access(pomXmlPath, constants.F_OK);
            return true;
        } catch (err) {
            return false;
        }
    }

    static platformText(binding) {
        if (!PLATFORM_TYPES[binding.type]) throw new Error(`Unexpected binding type "${binding.type}"`);
        return PLATFORM_TYPES[binding.type]
    }

    static bindingText(binding, highlight = t => t) {
        switch (binding.type) {
            case 'cf':
                if (binding.key) {
                    return `managed service ${highlight(binding.instance + ':' + binding.key)}`
                } else {
                    return `user provided service ${highlight(binding.instance)}`
                }
            case 'k8s':
                if (binding.name) {
                    return `service binding ${highlight(binding.name)}`
                } else {
                    return `secret ${highlight(binding.secret)}`
                }
            default:
                throw new Error('Internal Error');
        }
    }

    static logger = { log: console.log }
}

module.exports = BindingUtil
