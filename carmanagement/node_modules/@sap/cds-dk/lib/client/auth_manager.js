const axios = require('axios');

require('../util/pruneAxiosErrors');

const cds = require('../cds');
const DEBUG = cds.debug('cli');
const { SettingsManager } = require('./settings_manager');
const { ParamCollection } = require('./params');
const { getMessage } = require('./helper/logging');

function addTokenInfo(params, authData) {
    params.set('token', authData.access_token);
    if (authData.expires_in) {
        params.set('tokenExpirationDate', Date.now() + authData.expires_in * 1000);
    } else {
        params.delete('tokenExpirationDate');
    }
    if (authData.refresh_token) {
        params.set('refreshToken', authData.refresh_token);
    } else {
        params.delete('refreshToken');
    }
}
function addUrlInfo(params, authData) {
    params.set('passcodeUrl', authData.passcode_url);
}
function* reqParams(params) {
    const url = params.get('tokenUrl');
    const d = {};
    if (params.has('subdomain')) {
        d.subdomain = params.get('subdomain');
    }
    if (params.has('refreshToken')) {
        d.refresh_token = params.get('refreshToken');
    } else if (params.has('passcode')) {
        d.passcode = params.get('passcode');
    }
    if (params.has('clientsecret')) {
        d.clientid = params.get('clientid');
        d.clientsecret = params.get('clientsecret');
    } else if (params.has('key')) {
        d.clientid = params.get('clientid');
        d.key = params.get('key');
    }
    const data = new URLSearchParams(d).toString();
    yield {
        method: 'post',
        url,
        data
    };
    yield {
        method: 'get',
        url: `${url}?${data}`,
        data: undefined
    };
}

async function retrieveTokenOrPasscodeUrl(params) {
    if (params.has('token') || !params.has('refreshToken') && !params.has('passcode') && params.has('passcodeUrl')) {
        return;
    }

    let retry;
    let authData;
    do {
        let response;
        for (const { method, url, data } of reqParams(params)) {
            try {
                DEBUG?.(`Getting authentication token or passcode URL from ${method.toUpperCase()} ${params.obfuscateQueryParams(url)}`);
                response = await axios[method](url, data);
            } catch (error) {
                if (error.status === 404) { // may represent 405 in case of wrong method
                    continue;
                }
                throw getMessage('Failed to get authentication token', { error });
            }
            if (response) {
                break;
            }
        }
        if (!response) {
            throw 'Failed to get authentication token';
        }
        authData = response.data;

        retry = !authData.access_token && params.has('refreshToken') && (params.delete('refreshToken'), true);
    } while (retry);

    if (authData.access_token) {
        addTokenInfo(params, authData);
    }
    if (authData.passcode_url) {
        addUrlInfo(params, authData);
    }
}


module.exports = class AuthManager {

    static async login(paramValues) {
        SettingsManager.init();
        const params = new ParamCollection(paramValues);
        await SettingsManager.loadAndMergeSettings(params);
        if (params.has('username')) {
            params.set('reqAuth', { auth: { username: params.get('username'), password: params.get('password') } });
        } else if (!params.get('skipToken')) {
            await retrieveTokenOrPasscodeUrl(params);
            if (!params.has('token')) {
                if (params.get('saveData')) {
                    await SettingsManager.saveSettings(params);
                }
                throw `Failed to login: no valid token or passcode provided. Get a passcode${
                    params.get('passcodeUrl') ? ' from ' + params.get('passcodeUrl') : ''
                } and supply the code when re-running the command`;
            }
            params.set('reqAuth', { headers: { Authorization: 'Bearer ' + params.get('token') } });
        }

        if (params.get('saveData')) {
            await SettingsManager.saveSettings(params); // saves token conditionally
        }

        return params;
    }

    static async logout(paramValues) {
        SettingsManager.init();
        const params = new ParamCollection(paramValues);
        if (params.get('clearInvalid')) {
            await SettingsManager.deleteInvalid();
        } else {
            await SettingsManager.deleteToken(params);
            if (params.get('deleteSettings')) {
                await SettingsManager.deleteSettingsWithoutToken(params);
            }
        }
    }

}
